\subsection{Inverse power method}

The \definition{Inverse Power method} is used to \textbf{find the smallest eigenvalues of a matrix}, rather than the largest as its brother the Power Method does.

\highspace
\begin{flushleft}
    \textcolor{Green3}{\faIcon{tools} \textbf{Algorithm}}
\end{flushleft}
We use the fact that the eigenvalues of $A^{-1}$ are the reciprocals of those of $A$. Hence the \textbf{smallest eigenvalue of $A$ is the reciprocal of the largest eigenvalue of} $A^{-1}$.
\begin{enumerate}
    \item \textbf{Start with an initial guess}, nonzero vector $\mathbf{q}^{\left(0\right)}$ such that its norm is one $\left|\left|\mathbf{q}^{\left(0\right)}\right|\right| = 1$.
    \item \textbf{Iteration}. For each $k \ge 0$:
    \begin{enumerate}
        \item Solve the system:
        \begin{equation*}
            A\mathbf{z}^{\left(k+1\right)} = \mathbf{q}^{\left(k\right)}
        \end{equation*}

        \item After each system solution, normalize the vector to prevent it from growing too large:
        \begin{equation*}
            \mathbf{q}^{\left(k+1\right)} = \dfrac{
                \mathbf{z}^{\left(k+1\right)}
            }{
                \left|\left|\mathbf{z}^{\left(k+1\right)}\right|\right|
            }
        \end{equation*}

        \item Computes the Rayleigh quotient (see page \pageref{eq: Rayleigh quotient} for more details).
        \begin{equation*}
            \sigma^{\left(k+1\right)} = \left[\mathbf{q}^{\left(k+1\right)}\right]^{H} A\mathbf{q}^{\left(k+1\right)}
        \end{equation*}
    \end{enumerate}
    \item \textbf{Repeat until we meet a specific stopping criteria}.
\end{enumerate}

\highspace
\begin{flushleft}
    \textcolor{Red2}{\faIcon{dollar-sign} \textbf{How much does it cost?}}
\end{flushleft}
It depends on the matrix used:
\begin{itemize}
    \item \textbf{Dense matrix}. Each iteration costs $\approx n^{3}$ operations.
    \item \textbf{Sparse matrix}. Each iteration costs only $\approx n \cdot m$, where $n$ is the number of rows or columns of the square matrix and $m$ the number of non-zero elements.
\end{itemize}

\highspace
\begin{flushleft}
    \textcolor{Green3}{\faIcon{network-wired} \textbf{Can it be parallelized?}}
\end{flushleft}
The overall convergence of the method may be sequential because the result of one iteration is needed to compute the next. Therefore, while some components of the algorithm can be parallelized, the entire method isn't inherently parallel.