\subsection{Risoluzione di Sistemi di Equazioni Lineari}

\subsubsection{Metodi diretti}

Si consideri la matrice di dimensione $n \times n$:
\begin{equation*}
    A = \begin{bmatrix}
        1 & 1 & 1 & 1 & \cdots & 1 \\
        1 & -1 & 0 & 0 & \cdots & 0 \\
        0 & 1 & -1 & 0 & \cdots & 0 \\
        \vdots & 0 & \ddots & \ddots & & \vdots \\
        \vdots & \vdots & & \ddots & \ddots & \vdots \\
        0 & 0 & 0 & \cdots & 1 & -1
    \end{bmatrix}
\end{equation*}
E $\mathbf{b}$ il vettore di dimensione $n$:
\begin{equation*}
    \mathbf{b} = \left[ 2, 0, 0, \dots, 0 \right]^{T}
\end{equation*}
\begin{enumerate}
    \item Si ponga $n=20$ e si assegnino in MATLAB la matrice $A$ e il vettore dei termini noti $\mathbf{b}$.
    \lstinputlisting[language=MATLAB]{code/risoluzione-di-sistemi-di-equazioni-lineari/metodi-diretti/step1.m}
    La funzione \texttt{diag} ha un parametro particolare, \href{https://www.mathworks.com/help/releases/R2024a/matlab/ref/diag.html#bt79o5i-1-k}{vedi la documentazione}.

    
    \item Si calcoli la fattorizzazione LU della matrice $A$, mediante la funzione MATLAB \texttt{lu}. Verificare che la tecnica del pivoting non è stata usata in questo caso.
    \lstinputlisting[language=MATLAB]{code/risoluzione-di-sistemi-di-equazioni-lineari/metodi-diretti/step2.m}
    Si veda a pagina \pageref{eq: pivoting} la spiegazione della matrice di permutazione.


    \newpage


    \item Scrivere una funzione MATLAB \texttt{fwsub.m} che, dati in ingresso una matrice triangolare inferiore $L \in \mathbb{R}^{n \times n}$ e un vettore $\mathbf{f} \in \mathbb{R}^{n}$ restituisca in uscita il vettore $\mathbf{x}$, soluzione del sistema $L \mathbf{x} = \mathbf{f}$, calcolata mediante l'algoritmo della sostituzione in avanti (\emph{forward substitution}). L'intestazione della funzione sarà ad esempio: \texttt{[x] = fwsub(L, f)}.

    Analogamente, scrivere la funzione \texttt{bksub.m} che implementi l'algoritmo della sostituzione all'indietro (\emph{backward substitution}) per matrici triangolari superiori ($U$). Per controllare che le matrici $L$ e $U$ passate a \texttt{fwsub.m} e \texttt{bksub.m} siano effettivamente triangolari, è possibile utilizzare i comandi MATLAB \texttt{triu} e \texttt{tril} che, data una matrice, estraggono rispettivamente la matrice triangolare superiore e la matrice triangolare inferiore.

    Per creare una funzione, in MATLAB viene utilizzata la seguente sintassi:
\begin{lstlisting}[language=MATLAB]
function output_params = function_name(input_params)
    % Statements
end\end{lstlisting}
    Introdotta la sintassi, si introduce il codice della funzione \texttt{fwsub.m}:
    \lstinputlisting[language=MATLAB]{code/risoluzione-di-sistemi-di-equazioni-lineari/metodi-diretti/fwsub.m}
    Analogamente, si presenta il codice della funzione \texttt{bksub.m}:
    \lstinputlisting[language=MATLAB]{code/risoluzione-di-sistemi-di-equazioni-lineari/metodi-diretti/bksub.m}

    
    \item Risolvere numericamente, utilizzando le funzioni \texttt{fwsub.m} e \texttt{bksub.m} implementate al punto precedente, i due sistemi triangolari necessari per ottenere la soluzione del sistema di partenza $A\mathbf{x} =\mathbf{b}$ mediante la fattorizzazione LU.

    Si utilizza la tecnica del pivoting e l'equazione \ref{eq: pivoting - sistemi triangolari} a pagina \pageref{eq: pivoting - sistemi triangolari}:
    \lstinputlisting[language=MATLAB]{code/risoluzione-di-sistemi-di-equazioni-lineari/metodi-diretti/step3.m}


    \newpage


    \item Si calcoli la norma 2 dell'errore relativo
    \begin{equation*}
        \left|\left| \mathbf{err_{rel}} \right|\right| = \dfrac{
            \left|\left| \mathbf{x} - \widehat{\mathbf{x}} \right|\right|
        }{
            \left|\left| \mathbf{x} \right|\right|
        }
    \end{equation*}
    E la norma 2 del residuo normalizzata:
    \begin{equation*}
        \left|\left| \mathbf{r} \right|\right| = \dfrac{
            \left|\left| \mathbf{b} - A \widehat{\mathbf{x}} \right|\right|
        }{
            \left|\left| \mathbf{b} \right|\right|
        }
    \end{equation*}
    Sapendo che la soluzione esatta è il vettore di componenti:
    \begin{equation*}
        \mathbf{x}\left(i\right) = \dfrac{2}{n} \hspace{2em} i = 1, \dots, n
    \end{equation*}
    Si commenti il risultato ottenuto basandosi sul valore del numero di condizionamento della matrice $A$ (si utilizzino i comandi \texttt{norm} e \texttt{cond}).

    Il comando \texttt{norm} è stato spiegato a pagina \pageref{lab: norm}.
    \lstinputlisting[language=MATLAB]{code/risoluzione-di-sistemi-di-equazioni-lineari/metodi-diretti/step4.m}


    \item Si ripeta il punto precedente per $n = 10,20,40,80,160$. Si rappresentino su un grafico in scala semi-logaritmica gli andamenti dell'errore relativo, del residuo normalizzato (si usa dire residuo normalizzato per la norma normalizzata del residuo) e del numero di condizionamento in funzione di $n$. Commentare il grafico ottenuto.
    \lstinputlisting[language=MATLAB]{code/risoluzione-di-sistemi-di-equazioni-lineari/metodi-diretti/step5.m}

    La seguente figura mostra l'andamento dell'errore relativo, del residuo normalizzato e del numero di condizionamento in funzione di $n$, in scala semi-logaritmica. Si noti che sia il residuo normalizzato sia l'errore relativo sono molto piccoli, dall'ordine di $10^{-16}$, conseguenza del fatto che il numero di condizionamento $K\left(A\right)$ è in questo caso relativamente piccolo.

    \begin{figure}[!htp]
        \centering
        \includegraphics[width=.7\textwidth]{img/metodi-diretti.pdf}
        \caption{Andamento dell'errore relativo, del residuo normalizzato e del numero di condizionamento in funzione di $n$.}
    \end{figure}
\end{enumerate}

\newpage

\subsubsection{Metodi iterativi}

I metodi iterativi stazionari sono considerati in genere nella seguente forma:
\begin{equation*}
    \mathbf{x}^{\left(k+1\right)} = B\mathbf{x}^{\left(k\right)} + \mathbf{f} \hspace{2em} k \ge 0
\end{equation*}
Dove $B$ è detta matrice di iterazione. $B$ e $\mathbf{f}$ identificano il metodo.

\paragraph{Metodo di Jacobi}

Si consideri la matrice diagonale $D$ degli elementi diagonali di $A$. Tale matrice è facilmente invertibile, se gli $a_{ii} \ne 0, i = 1, \dots, n$, in quanto:
\begin{equation*}
    D = \begin{pmatrix}
        a_{11}  & 0     & 0     & \cdots    & 0     \\
        0       & a_{22}& 0     & \cdots    & 0     \\
        \vdots  & 0     & \ddots& \ddots    & \vdots\\
        \vdots  & \vdots& \ddots& \ddots    & 0     \\
        0       & 0     & \cdots& 0         & a_{nn}
    \end{pmatrix}
    \Longrightarrow
    D^{-1} = \begin{rowequmat}{ccccc}
        \dfrac{1}{a_{11}}   & 0                 & 0     & \cdots    & 0     \\ [.3em]
        0                   & \dfrac{1}{a_{22}} & 0     & \cdots    & 0     \\ [.3em]
        \vdots              & 0                 & \ddots& \ddots    & \vdots\\ [.3em]
        \vdots              & \vdots            & \ddots& \ddots    & 0     \\ [.3em]
        0                   & 0                 & \cdots& 0         & \dfrac{1}{a_{nn}}
    \end{rowequmat}
\end{equation*}
E il metodo può essere scritto direttamente in forma matriciale:
\begin{gather*}
    \mathbf{x}^{\left(0\right)} \text{ assegnato} \\
    \mathbf{x}^{\left(k+1\right)} = B_{J}\mathbf{x}^{\left(k\right)} + \mathbf{f}_{J} \\
\end{gather*}
Dove $B_{J} = I - D^{-1} A = D^{-1} \left(D-A\right)$ è la matrice di iterazione di Jacobi e $\mathbf{f}_{J} = D^{-1} \mathbf{b}$

\paragraph{Metodo di Gauss-Seidel}

Questo metodo si differenza dal metodo di Jacobi per il fatto che considera, oltre alla matrice $D$, anche le due matrici $-E$ e $-F$ triangolari superiore e inferiore della matrice $A$, ovvero:
\begin{equation*}
    -E = \begin{bmatrix}
        0 & 0 & 0 & \cdots &  0 \\
        a_{21} & 0 & 0 & \cdots & 0 \\
        \vdots & a_{32} & \ddots & \ddots & \vdots \\
        \vdots & \vdots & \ddots & \ddots & 0 \\
        a_{n1} & a_{n2} & \cdots & a_{nn-1} & 0
    \end{bmatrix}
    \hspace{2em}
    -F = \begin{bmatrix}
        0 & a_{12} & a_{13} & \cdots & a_{1n} \\
        0 & 0 & a_{23} & \cdots & a_{2n} \\
        \vdots & 0 & \ddots & \ddots & \vdots \\
        \vdots & \vdots & \ddots & \ddots & a_{n-1n} \\
        0 & 0 & \cdots & 0 & 0
    \end{bmatrix}
\end{equation*}
Dunque, il seguente algoritmo o le seguenti istruzioni:
\begin{gather*}
    \mathbf{x}^{\left(0\right)} \text{ assegnato} \\
    \mathbf{x}^{\left(k+1\right)} = B_{GS}\mathbf{x}^{\left(k\right)} + \mathbf{f}_{GS} \\
\end{gather*}
Dove $B_{GS} = \left(D-E\right)^{-1}F$ è la matrice d'iterazione di Gauss-Seidel e $\mathbf{f}_{GS} = \left(D-E\right)^{-1}\mathbf{b}$.

\paragraph{Esercizio}

Si considerino la matrice:
\begin{equation*}
    A = \begin{bmatrix}
        9 & -3 & 1 & & & & \\
        -3 & 9 & -3 & 1 & & & \\
        1 & -3 & 9 & -3 & 1 & & \\
        & 1 & -3 & 9 & -3 & 1 & \\
        && 1 & -3 & 9 & -3 & 1 \\
        &&& 1 & -3 & 9 & -3 \\
        &&&& 1 & -3 & 9 
    \end{bmatrix}
\end{equation*}
E il termine noto:
\begin{equation*}
    \mathbf{b} = \begin{bmatrix}
        7 & 4 & 5 & 5 & 5 & 4 & 7 
    \end{bmatrix}^{T}
\end{equation*}
\begin{enumerate}
    \item Costruire la matrice $A$ (utilizzando i comandi Matlab \texttt{diag} e \texttt{ones}) e determinare il numero di elementi non nulli tramite il comando \texttt{nnz}. La matrice $A$ è a dominanza diagonale per righe? È simmetrica e definita positiva?

    \item Si calcolino le matrici di iterazione $B_{J} = D^{-1}\left(D - A\right)$ e $B_{GS} = \left(D - E\right)^{-1}F$ associate rispettivamente ai metodi di Jacobi e Gauss-Seidel e i relativi raggi spettrali. La condizione necessaria e sufficiente per la convergenza del metodo iterativo è soddisfatta in entrambi i casi?

    \item Scrivere la funzione Matlab che implementi il metodo di Jacobi inversione \emph{matriciale} per il sistema lineare $A\mathbf{x} = \mathbf{b}$. L'intestazione della funzione sarà la seguente:
    \begin{equation*}
        \texttt{[x,k] = jacobi(A,b,x0,toll,nmax).}
    \end{equation*}
    Il processo iterativo si arresta quando:
    \begin{equation*}
        \dfrac{\left|\left|\mathbf{r}^{(k)}\right|\right|}{\left|\left|\mathbf{b}\right|\right|} \leq \texttt{toll}
    \end{equation*}
    (criterio d'arresto del residuo normalizzato).

    \item Scrivere una funzione Matlab che implementi il metodo di Gauss-Seidel inversione \emph{matriciale} per il sistema lineare $A\mathbf{x} = \mathbf{b}$. L'intestazione della funzione sarà la seguente:
    \begin{equation*}
        \texttt{[x,k] = gs(A,b,x0,toll,nmax).}
    \end{equation*}

    \item Costruire il termine noto $\mathbf{b}$. Utilizzando le funzioni costruite nei punti 3 e 4, risolvere il sistema $A\mathbf{x} = \mathbf{b}$ ponendo $x^{(0)} = \left[0,0,\dots,0\right]^{T}$, $\texttt{toll} = 10^{-6}$ e $\texttt{nmax} = 1000$. Confrontare il numero di iterazioni necessarie per arrivare a convergenza per i due metodi e commentare i risultati ottenuti.
\end{enumerate}
